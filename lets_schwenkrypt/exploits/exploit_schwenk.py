import sys
from gameserver import GameServer

PORT = 4711


def exploit(cipher, parameters):
    import string
    from math import ceil
    from algebraOpt import GFElement
    from hashlib import sha512

    xorParams = parameters["schwenkerid"]
    bases = []
    powers = []
    coeffs = []
    for l in parameters["schwenkingoptions"]:
        bases += [l[0]]
        powers += [len(l ) -2]
        coeffs += [l[1:]]

    NUM_BLOCKS = len(bases)

    # BLOCK_SIZE = 32

    def toNumber(s):
        return int(s.hex(), 16)

    def estimateSize(index):
        baseBits = len(bin(bases[index])[2:])
        return int(ceil(0.125*(baseBits-1)*powers[index]))

    def gfeFromNumber(n, index):
        return GFElement.fromNumber(n, bases[index], powers[index], coeffs[index])

    def gfeFromString(s, index):
        return GFElement.fromString(s, bases[index], powers[index], coeffs[index])

    def isValidPlaintext(s):
        return all([x in map(ord, string.printable) for x in s])

    def hasValidPadding(s):
        return all([x == s[-1] for x in s[-s[-1]:]])

    def unpad(s):
        return s[:-s[-1]]

    # print("decrypting.")
    plain = b""
    sizeOffsets = [0 ,1 ,2 ,-1] # 0 must be the first element. #[0,1,2,3,-1,-2]
    ## Try to figure out the last two keys. We need a nested loop because we don't know for sure how long the ciphertext of each hash half is.
    # We can use assertions on the calculations to eliminate most of the wrong candidates. After that we can check the padding in the third last block.
    # Checking the padding will, in combination with the assertions on the computations, give a result which is very, very, ..., very likely unique.

    # i refers to the last block, j refers to the second last block.
    iExpected = estimateSize(-1)
    jExpected = estimateSize(-2)
    found = False
    for i in sizeOffsets:
        c_i = cipher[-iExpected - i:]
        # print("decrypting. 1")
        for j in sizeOffsets:
            # print("testing %d, %d " %( i +iExpected, j+ jExpected))
            hashCipherSize = iExpected + i + jExpected + j
            c_j = cipher[-hashCipherSize: -iExpected - i]
            h = sha512(cipher[:-jExpected - j - iExpected - i]).digest()
            m_i = h[32:]
            m_j = h[:32]

            # Try to compute the keys.
            try:
                # TODO: perform gcd check here -> might save computing one root.
                radix = toNumber(m_i) ^ xorParams[-1]
                radicant = gfeFromString(c_i, -1)
                k_i_out = radicant.nthRoot(radix)
                radix = toNumber(m_j) ^ xorParams[-2]
                radicant = gfeFromString(c_j, -2)
                k_j_out = radicant.nthRoot(radix)
            except Exception as e:
                # print(e)
                continue

            # We may actually find quite a number of possible values here. We can't perform any further checks on the data we have so far.
            # print "---------TRYING %d, %d"%(i+iExpected, j+jExpected)

            # We can compute the input IV of block i
            # Note that these cannot fail because F_i has more elements than F_j
            k_i_in = gfeFromNumber(k_j_out.toNumber(), -1)  # The computation needs to be done in the field of block i
            IV_i_in = k_i_in * k_i_out.inverse()

            # We will always have one more block (reffered to by k). Worst case, it consists entirely of padding.
            # We can compute its key and IV:
            try:
                # Sizes can be off. This will already filter out most of the wrong cases.
                IV_j_out = gfeFromNumber(IV_i_in.toNumber(), -2)
                one_j = gfeFromNumber(1, -2)
                k_j_in = IV_j_out * (k_j_out.inverse() + one_j).inverse()
                IV_j_in = IV_j_out - k_j_in
                # print "IV input block j:", IV_j_in.toNumber()
                # print "k input block j:", k_j_in.toNumber()

                # These should also be within the try block: If choices are wrong so far, these might not fit into the smaller field.
                k_k_out = gfeFromNumber(k_j_in.toNumber(), -3)
                IV_k_out = gfeFromNumber(IV_j_in.toNumber(), -3)
            except Exception as e:
                # print(e)
                continue

            kFound = False
            kExpected = estimateSize(-3)
            for k in sizeOffsets:
                # print("Trying k:", k + kExpected)
                c_block = cipher[-hashCipherSize - kExpected - k: -hashCipherSize]
                try:
                    c_elem = gfeFromString(c_block, -3)
                    # print "c_elem:", c_elem.toNumber()
                    c_plain = c_elem.nthRoot(k_k_out.toNumber() ^ xorParams[-3]).toString()
                except Exception as e:
                    # print(e)
                    continue

                if not hasValidPadding(c_plain):
                    continue
                c_plain = unpad(c_plain)
                if not isValidPlaintext(c_plain):
                    continue
                plain += c_plain
                print("Found plaintext fragment:", c_plain)
                kFound = True
                break

            if not kFound:
                continue

            # Now compute the remaining blocks. We'll skip backtracking: The above checks should already give a unique result.
            remainingCipher = cipher[:-hashCipherSize - kExpected - k]
            # k_next and IV_next are the parameters used in the next (w.r.t. encryption order, e.g., -3 is next after -4) block
            k_next_out = k_k_out
            IV_next_out = IV_k_out
            for blockIndex in range(NUM_BLOCKS - 4, -1, -1):
                # print("decrypting. 2")
                one_b = gfeFromNumber(1, blockIndex + 1)
                k_next_in = IV_next_out * (k_next_out.inverse() + one_b).inverse()
                IV_next_in = IV_next_out - k_next_in
                # print "IV input of block b+1:", IV_next_in.toNumber()
                # print "k input of block b+1:", k_next_in.toNumber()

                k_b_out = gfeFromNumber(k_next_in.toNumber(), blockIndex)
                IV_b_out = gfeFromNumber(IV_next_in.toNumber(), blockIndex)

                bExpected = estimateSize(blockIndex)
                bFound = False
                for bOffset in sizeOffsets:
                    # Special case for the first block: We need to use the entire rest of the cipher
                    if blockIndex == 0 and -bExpected - bOffset != -len(remainingCipher):
                        continue
                    c_block = remainingCipher[-bExpected - bOffset:]
                    try:
                        # This can still go wrong: If we pick too much ciphertext, it will not fit into the field.
                        c_elem = gfeFromString(c_block, blockIndex)
                    except Exception as e:
                        # print(e)
                        continue
                    # No try here: At this point, we are very sure that we have decrypted correctly so far. Backtracking here would also be rather messy.
                    c_plain = c_elem.nthRoot(k_b_out.toNumber() ^ xorParams[blockIndex]).toString()
                    if not isValidPlaintext(c_plain):
                        continue
                    plain = c_plain + plain
                    print("Found plaintext fragment:", c_plain)
                    bFound = True
                    break

                if not bFound:
                    raise Exception("Decryption failed.")
                remainingCipher = remainingCipher[:-bExpected - bOffset]
                k_next_out = k_b_out
                IV_next_out = IV_b_out

            return plain.decode("utf-8")


if __name__ == "__main__":
    assert len(sys.argv) >= 4, "Needs flag ids in fourth argument"
    target = sys.argv[1]
    flagIds = sys.argv[3].split(",")

    for flagId in flagIds:
        cipher, params = GameServer.retrieveCipher(target, PORT, flagId)
        if params["method"] == "schwenk":
            plain = exploit(cipher, params)
            print(plain)