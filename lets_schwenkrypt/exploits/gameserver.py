"""
Basically a copy of _gameserver.py from the checkers/ folder.
Notice that the exploit scripts don't have access to gamelib, therefore this version here also has the exceptions removed.
"""

import socket
import json
from binascii import unhexlify

DEFAULT_TIMEOUT = 7
SHA512_HEX_LEN = 128


class SimpleSocket(object):
    def __init__(self, socket):
        self.socket = socket
        self.rbuf = ""

    def recvline(self):
        while not "\n" in self.rbuf:
            r = self.socket.recv(4096)
            if not r:
                self.socket.shutdown(socket.SHUT_RDWR)
                self.socket.close()
                print("xxx")
            self.rbuf += r.decode("utf-8")
        i = self.rbuf.index("\n")
        line = self.rbuf[:i]
        self.rbuf = self.rbuf[i + 1:]
        return line.strip()

    def sendline(self, msg: str):
        if len(msg) == 0 or msg[-1] != "\n":
            msg += "\n"
        self.socket.sendall(msg.encode("utf-8"))

    def close(self):
        self.socket.shutdown(socket.SHUT_RDWR)
        self.socket.close()

    @staticmethod
    def connect(host, port, timeout=DEFAULT_TIMEOUT):
        socket.setdefaulttimeout(timeout)
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((host, port))
        return SimpleSocket(s)


class GameServer():
    @staticmethod
    def sendCommand(host: str, port: int, cmd: str, sig: str, timeout=DEFAULT_TIMEOUT):
        toException = False
        try:
            s = SimpleSocket.connect(host, port, timeout=timeout)

            def expectLine(line):
                l = s.recvline()
                if l != line:
                    raise Exception(f"""Unexpected behaviour: got "{l}", expected "{line}".""")

            expectLine("command:")
            s.sendline(cmd)
            expectLine("signature:")
            s.sendline(sig)
            res = s.recvline()
            s.close()
            return res
        except (socket.timeout, ConnectionRefusedError):
            toException = True
            try:
                s.close()
            except:
                pass
        if toException:
            raise Exception(f"Team {host} seems to be offline")

    @staticmethod
    def retrieveCipher(host: str, port: int, flagId: str, timeout=DEFAULT_TIMEOUT) -> (bytes, dict):
        """
        :return: A tuple (ciphertext, dictionary of parameters).
        """
        cmd = """{"command":"db_retrieve_item", "data":"%s"}""" % flagId
        obj = GameServer.sendCommand(host, port, cmd, "", timeout=timeout)
        try:
            obj = json.loads(obj)
        except Exception as e:
            raise Exception(f"Got {type(e)}, while parsing json. Exception message: {e}")
        if not "status" in obj.keys():
            raise Exception("Missing key: status")
        if obj["status"] == "error":
            if not "msg" in obj.keys():
                raise Exception("Missing key: msg")
            if obj["msg"] == "No such item!":
                raise Exception("Flag missing.")
            raise Exception("Got answer: " + json.dumps(obj))
        if obj["status"] != "db_retrieve_success":
            raise Exception(
                f"""Unexpected status: got "{obj["status"]}", " expected "db_retrieve_success". Full response: {json.dumps(obj)}""")
        if not "data" in obj.keys():
            raise Exception("Missing key: data")
        if not "params" in obj.keys():
            raise Exception("Missing key: params")
        try:
            cipher = unhexlify(obj["data"])
        except:
            raise Exception("Invalid cipher format")
        return cipher, obj["params"]
