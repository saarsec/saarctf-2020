"""
This is a somewhat optimized but unobfuscated implementation of the algebra stuff needed for proper schwenking.
It much faster than the really naive implementation but still significantly slower than the obfuscated version which is part of the public files.
"""
from Crypto.Util.number import inverse as modinv
from sympy.ntheory import factorint
from itertools import zip_longest
from sympy.polys.domains import ZZ
from sympy.polys.galoistools import gf_from_int_poly
from sympy import gcd

class ZpXElement:
    # This class represents polynomials in Z_p[X].
    # Highest coefficients go to the right end of the coefficients list
    # All operations always truncate leading zero monomials, i.e., the last element of in the coefficients represents the nonzero monomial with highest exponent.
    def __init__(self, p, coeffs, applyMod=True):
        assert type(coeffs) == list
        assert len(coeffs) > 0
        assert type(p) in [int, int]
        assert p > 1
        # TODO: The primality tests gobbles 70%+ of the total computation time. Remove it later.
        #factors = factorint(p)
        #assert len(factors) == 1 and factors.values()[0] == 1
        self.p = p
        self.coeffs = coeffs
        if applyMod:
            self.applyModulus()
            

        
    def applyModulus(self):
        coeffs = gf_from_int_poly(self.coeffs[::-1], self.p)[::-1] # Yep, reversing the list twice is faster than applying the modulus manually
        #print "after:", self.coeffs
        for i in range(len(coeffs))[::-1]:
            if coeffs[i] != 0:
                self.coeffs = coeffs[:i+1]
                return
        #self.coeffs = [self.coeffs[0]] # In this case, we don't care if c[0] == 0, we need at least one element.
        if len(coeffs) == 0:
            self.coeffs = [0]
            
    def trimZeros(self):
        for i in range(len(self.coeffs))[::-1]:
            if self.coeffs[i] != 0:
                self.coeffs = self.coeffs[:i+1]
                return
        #self.coeffs = [self.coeffs[0]] # In this case, we don't care if c[0] == 0, we need at least one element.
        self.coeffs = [0]
    
    def newElement(self, coeffs):
        return ZpXElement(self.p, coeffs)
    
    def newMonomial(self, coeff, degree):
        assert 0 <= degree
        return self.newElement(degree*[0] + [coeff])
    
    def newZero(self):
        return self.newElement([0])
    
    def newOne(self):
        return self.newElement([1])
    
    def degree(self):
        # As long as we use applyModulus() rigorously, this one is easy.
        assert self.coeffs[-1] != 0 or len(self.coeffs) == 1 # We may only see a zero here if the entire polynomial is zero.
        if len(self.coeffs) == 1:
            if self.coeffs[-1] != 0:
                return 0
            return -1 # Mathematically, this should be -infinity but -1 should do just fine as long as we are careful.
        return len(self.coeffs)-1
    
    def leadingMonomial(self):
        # Returns the coefficient and exponent of the leading monomial or 0, -1 if the entire polynomial is 0.
        return self.coeffs[-1], self.degree()
    
        
    def __str__(self):
        s = ""
        for i,c in enumerate(self.coeffs):
            s = "%d*X^%d + "%(c, i) + s
        return s[:-3]
    
    def __eq__(self, rhs):
        return self.p == rhs.p and self.coeffs == rhs.coeffs
    
    def __ne__(self, rhs):
        return self.p != rhs.p or self.coeffs != rhs.coeffs
        
    
    def __add__(self, rhs):
        assert isinstance(rhs, ZpXElement)
        assert self.p == rhs.p, "Polynomials must be from the same ring."
        # Tested: Computing modulus directly is faster.
        leftCoeffs = self.coeffs # Improves caching or something (maybe prevents pointer aliasing) -> faster than using self.coeffs all the time.
        rightCoeffs = rhs.coeffs
        p = self.p
        ll = len(leftCoeffs)
        lr = len(rightCoeffs)
        if ll < lr:
            newCoeffs = lr*[0]
            for i in range(ll):
                newCoeffs[i] = (leftCoeffs[i] + rightCoeffs[i])%p
            for i in range(ll, lr):
                newCoeffs[i] = rightCoeffs[i]
        else:
            newCoeffs = ll*[0]
            for i in range(lr):
                newCoeffs[i] = (leftCoeffs[i] + rightCoeffs[i])%p
            for i in range(lr, ll):
                newCoeffs[i] = leftCoeffs[i]
        x = ZpXElement(p, newCoeffs, applyMod=False)
        x.trimZeros()
        return x
                
    
    def __neg__(self):
        return self.newElement([-x for x in self.coeffs])
    
    def __sub__(self, rhs):
        return self + (-rhs)
    
    
    def __mul__(self, rhs):
        assert isinstance(rhs, ZpXElement) or type(rhs) in [int, int], type(rhs)
        assert not isinstance(rhs, ZpXElement) or (self.p == rhs.p), "Polynomials must be from the same ring."
        
        p = self.p
        
        if isinstance(rhs, ZpXElement):
            leftCoeffs = self.coeffs
            rightCoeffs = rhs.coeffs
            accu = (len(leftCoeffs)+len(rightCoeffs)-1)*[0]
            erc = list(enumerate(rightCoeffs))
            for i, cl in enumerate(leftCoeffs):
                for j, cr in erc:
                    accu[i+j] = accu[i+j] + cl*cr
            return ZpXElement(p, accu)
        else:
            coeffs = self.coeffs
            ll = len(coeffs)
            accu = ll*[0]
            for i in range(ll):
                accu[i] = (coeffs[i]*rhs)%p
            x = ZpXElement(p, accu, applyMod=False)
            x.trimZeros()
            return x
        assert False
        
    
    def polyLongDiv(self, rhs):
        assert isinstance(rhs, ZpXElement)
        assert self.p == rhs.p, "Polynomials must be from the same ring."
        assert rhs.degree() > -1
        
        
        remainder = self
        quotient = self.newZero()
        divisorCoeff, divisorDegree = rhs.leadingMonomial()
        while remainder.degree() >= rhs.degree():
            remainderCoeff, remainderDegree = remainder.leadingMonomial()
            quotLeading = self.newMonomial(remainderCoeff*modinv(divisorCoeff, self.p), remainderDegree-divisorDegree)
            quotient = quotient + quotLeading
            remainder = remainder - rhs*quotLeading

        return quotient, remainder
    
    def egcd(self, rhs):
        if self.degree() == -1:
            return (rhs, self.newZero(), self.newOne())
        else:
            quot, rem = rhs.polyLongDiv(self)
            g, y, x = rem.egcd(self)
            return (g, x - (quot) * y, y)


class GFElement:
    def __init__(self, base, power, modulus, element, applyMod=True):
        assert isinstance(modulus, ZpXElement)
        assert isinstance(element, ZpXElement)
        assert base == modulus.p and base == element.p
        assert power > 1
        assert modulus.degree() == power
        assert modulus.leadingMonomial()[0] == 1 # should always be the case. If not, things will get ugly.
        self.base = base
        self.power = power
        self.modulus = modulus
        self.element = element
        if applyMod:
            self.applyModulus()
        
    
    def applyModulus(self):
        # Applying the ZpX modulus once at the end is fastest.
        elemCoeffs = self.element.coeffs
        modCoeffs = self.modulus.coeffs
        l = len(modCoeffs)-1
        jRange = range(l)
        for i in range(len(elemCoeffs)-1, l-1, -1):
            mult = elemCoeffs[i]%self.base
            if mult != 0:
                elemCoeffs[i] = 0
                j = 0
                for j in jRange:
                    elemCoeffs[i-l+j] -= mult*modCoeffs[j]
            #i -= 1
        self.element = ZpXElement(self.base, elemCoeffs)

    def newElement(self, elem):
        return GFElement(self.base, self.power, self.modulus, elem)
    
    def newOne(self):
        return self.newElement(ZpXElement(self.base, [1]))
    
    def __eq__(self, rhs):
        return self.base == rhs.base and self.power == rhs.power and self.modulus == rhs.modulus and self.element == rhs.element
    
    def __ne__(self, rhs):
        return not self == rhs
    
    def __add__(self, rhs):
        assert isinstance(rhs, GFElement)
        assert self.base == rhs.base and self.power == rhs.power and self.modulus == rhs.modulus, "Elements must be from the same field."
        return self.newElement(self.element + rhs.element)
    
    def __neg__(self):
        return self.newElement(-self.element)
    
    def __sub__(self, rhs):
        return (self + (-rhs))
    
    def __mul__(self, rhs):
        r = self.newElement(self.element)
        r *= rhs
        return r
        
    def square(self):
        r = self.newElement(self.element)
        return r.isquare()
    
    
    def __imul__(self, rhs):
        #
        assert isinstance(rhs, GFElement) or type(rhs) in [int, int]
        assert not isinstance(rhs, GFElement) or (self.base == rhs.base and self.power == rhs.power and self.modulus == rhs.modulus), "Elements must be from the same field."

        if isinstance(rhs, GFElement):
            leftCoeffs = self.element.coeffs
            rightCoeffs = rhs.element.coeffs
            ll = len(leftCoeffs)
            rl = len(rightCoeffs)
            multLen = ll+rl-1
            accu = multLen*[0]
            degl = ll-1
            degr = rl-1
            modCoeffs = self.modulus.coeffs
            l = len(modCoeffs)-1
            jRange = range(l)
            p = self.base

            for d in range(multLen-1, l-1, -1):
                currentCoeff = 0
                if degl > d:
                    upper = d
                else:
                    upper = degl
                    
                if d-degr-1 > -1:
                    lower = d-degr-1
                else:
                    lower = -1
                    
                for i in range(upper, lower, -1):
                    currentCoeff += leftCoeffs[i]*rightCoeffs[d-i]
                accu[d] += currentCoeff
                mult = accu[d]%p
                if mult != 0:
                    for j in jRange:
                        accu[d-l+j] -= mult*modCoeffs[j]
                accu[d] = 0
                
            for d in range(min(l-1, multLen-1), -1, -1):
                currentCoeff = 0
                if degl > d:
                    upper = d
                else:
                    upper = degl
                    
                if d-degr-1 > -1:
                    lower = d-degr-1
                else:
                    lower = -1
                for i in range(upper, lower, -1):
                    currentCoeff += leftCoeffs[i]*rightCoeffs[d-i]
                accu[d] = (accu[d] + currentCoeff)%p
                
            #Cut off zeros:
            for i in range(multLen-1, -1, -1):
                if accu[i] != 0:
                    accu = accu[:i+1]
                    break
            if len(accu) == 0:
                #print "bla"
                accu = [0]
            self.element.coeffs = accu
            return self
        else:
            self.element = self.element*rhs
            return self
        
    def isquare(self):
        #return self*self
        coeffs = self.element.coeffs
        l = len(coeffs)
        multLen = l+l-1
        accu = multLen*[0]
        deg = l-1
        modCoeffs = self.modulus.coeffs
        lMod = len(modCoeffs)-1
        jRange = range(lMod)
        p = self.base

        for d in range(multLen-1, lMod-1, -1):
            currentCoeff = 0
            for i in range(deg, d-deg-1, -1):
                currentCoeff += coeffs[i]*coeffs[d-i]
            accu[d] += currentCoeff
            mult = accu[d]%p
            if mult != 0:
                offset = d-lMod
                for j in jRange:
                    accu[offset+j] -= mult*modCoeffs[j]
            accu[d] = 0
            
        for d in range(min(lMod-1, multLen-1), deg, -1):
            # This loop can occur if deg(element) < deg(mod)-1
            currentCoeff = 0
            for i in range(deg, d-deg-1, -1):
                currentCoeff += coeffs[i]*coeffs[d-i]
            accu[d] = (accu[d] + currentCoeff)%p
            
        for d in range(deg, -1, -1):
            currentCoeff = 0
            for i in range(d, -1, -1):
                currentCoeff += coeffs[i]*coeffs[d-i]
            accu[d] = (accu[d] + currentCoeff)%p
            
        #Cut off zeros:
        for i in range(min(multLen-1, lMod-1), -1, -1):
            if accu[i] != 0:
                accu = accu[:i+1]
                break
        if len(accu) == 0:
            #print "bla"
            accu = [0]
        self.element.coeffs = accu
        return self
    
    def __pow__(self, rhs):
        assert type(rhs) in [int, int]
        assert rhs >= 0
        if rhs == 0:
            return self.newOne()
        
        # TODO: check that ord(F) is not a multiple of rhs. Otherwise inverting the operation does (or might) not have a unique result.
        # TODO: This check will be subsumed by the condition gcd(exponent, fieldMultiplicativeOrder) == 1. This, we enforce for easy computation of n-th roots.
        res = self.newOne()
        for bit in bin(rhs)[2:]:
            res.isquare()
            if bit == '1':
                res.__imul__(self) # Yes... This is faster than using the operator. The operator has an overhead of 0,1 microseconds^^ Plus in obfuscation, we'd like to call some randomly named function anyways.
        return res
    
    

    def inverse(self):
        g, x, y = self.element.egcd(self.modulus)
        if g.degree() != 0:
            assert False
        else:
            # We can receive any unit (i.e., polynomial of degree 0) as gcd. In this case we have to adjust the result by multiplying with the inverse of the gcd.
            return self.newElement(x*modinv(g.coeffs[0], self.base))

    def inverseAlternative(self):
        # Much simpler but much, much slower.
        exp = (self.base**self.power)-2
        return self**exp
    
    def nthRoot(self, n):
        # TODO: This will not be part of the code we ship out.
        mOrder = self.base**self.power-1
        assert gcd(mOrder, n) == 1
        return self**modinv(n, mOrder)
        
    
    @staticmethod
    def fromNumber(n, base, power, modulusCoeffs):
        assert base**power >= n, "Not enough space: %d < %d"%(base**power, n)
        assert n >= 0
        coeffs = power*[0]
        i = 0
        while n != 0:
            c = n%base
            n = (n-c)//base
            coeffs[i] = c
            i += 1
            
        return GFElement(base, power, ZpXElement(base, modulusCoeffs), ZpXElement(base, coeffs))
        
    def toNumber(self):
        return sum(y*(self.base**x) for x,y in enumerate(self.element.coeffs))
        
    
    @staticmethod
    def fromString(s, base, power, modulusCoeffs):
        # return GFElement.fromNumber(int(s.encode('hex'),16), base, power, modulusCoeffs)
        return GFElement.fromNumber(int(s.hex(), 16), base, power, modulusCoeffs)
    
    def toString(self):
        s = hex(self.toNumber()).replace('L', '').replace('0x', '')
        if len(s) % 2 != 0:
            s = '0' + s
        import binascii
        return binascii.unhexlify(s)

    def __str__(self):
        return str(self.element) + "\nmod " + str(self.modulus)