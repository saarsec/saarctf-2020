# Handshake Exploit
The handshake (given in `handshake.go`) was vulnerable to a Man-in-the-Middle attack.

## Vulnerabilities 
The sign function has some interesting code:
```golang
hashed := hash(message[0:(8 + len(clientHandshake.Target) + 24)])

tmp, err := rsa.SignPKCS1v15(rand.Reader, key, crypto.SHA512, hashed)
if err != nil {
	return err
}
clientHandshake.Hmac = []byte(base64.URLEncoding.EncodeToString(tmp))
```
Hence, for building the signature we only take first 32 characters + the length of the target IP.
Now recap what parts the message consists off. We first have the public key followed, by the nonce,
the expiry date and the target. As the nonce is generated by the server, we can patch our own
services to answer handshake requests with a abnormal long nonce. By doing this we shift the expiry
data and the target out of the signature. That means that the client will create the signature
only using the public key and the nonce.

We also note another vulnerability in the checking of the nonce:
```golang
if !strings.Contains(clientHandshake.Nonce, nonce) {
	log.Printf("expected different nonce, wanted " + nonce + " got " + clientHandshake.Nonce)
	return false
}
```
This means that once we have a valid nonce we can pad it with arbitraty bytes and it will still 
be accepted.

## Exploit Steps
1: Wait for the Gameserver to connect to your own server and do not send a handshake response yet.  
2: Connect to the victim team and get their nonce.  
3: Manipulate the traffic (or patch your service) to answers the gameserver request 
   with the victim's nonce and append padding long enough 
   to evict the target and expiry date from the handshake signature.  
4: Receive the signed answer from the gameserver.  
5: Forward the answer to the victim team.  
6: Success! We are now authorized as the gameserver to the victim team.  

